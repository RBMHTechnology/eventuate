

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Event-sourced actors &mdash; Eventuate</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/tabbedcode.css" type="text/css" />
  

  
    <link rel="top" title="Eventuate" href="../index.html"/>
        <link rel="up" title="Reference" href="../reference.html"/>
        <link rel="next" title="Adapters" href="adapters.html"/>
        <link rel="prev" title="Event log" href="event-log.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

  
	<script src="//fonts.redbullmediahouse.com/snv5vzo.js"></script>
	<script>try{Typekit.load();}catch(e){}</script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          
          <a href="../index.html"><img src="../_static/RedBullMediaHouse-dark.png" class="logo" /></a>
        
        
		
<div role="search" class="searchbox">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Eventuate" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
	
        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#event-sourcing">Event sourcing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#event-collaboration">Event collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#event-log">Event log</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#event-bus">Event bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#event-ordering-and-consistency">Event ordering and consistency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#operation-based-crdts">Operation-based CRDTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#stream-processing-adapters">Stream processing adapters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#related-projects">Related projects</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#event-logs">Event logs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#event-sourcing">Event sourcing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#event-collaboration">Event collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#operation-based-crdts">Operation-based CRDTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#vector-clocks">Vector clocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../architecture.html#batching">Batching</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-guide.html">User guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#event-sourced-actors">Event-sourced actors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#detecting-concurrent-updates">Detecting concurrent updates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#tracking-conflicting-versions">Tracking conflicting versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#resolving-conflicting-versions">Resolving conflicting versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#operation-based-crdts">Operation-based CRDTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#event-sourced-views">Event-sourced views</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#conditional-requests">Conditional requests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-guide.html#event-driven-communication">Event-driven communication</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="api-docs.html">API docs</a></li>
<li class="toctree-l2"><a class="reference internal" href="event-log.html">Event log</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Event-sourced actors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-sourced-views">Event-sourced views</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-sourced-writers">Event-sourced writers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-sourced-processors">Event-sourced processors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#state-recovery">State recovery</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">Snapshots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-routing">Event routing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-driven-communication">Event-driven communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reliable-delivery">Reliable delivery</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-requests">Conditional requests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#command-stashing">Command stashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#behavior-changes">Behavior changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#failure-handling">Failure handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-serialization">Custom serialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="adapters.html">Adapters</a></li>
<li class="toctree-l2"><a class="reference internal" href="configuration.html">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../resources.html#articles">Articles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resources.html#presentations">Presentations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../download.html#binaries">Binaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../download.html#sources">Sources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../developers.html">Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../developers.html#contributing-to-eventuate">Contributing to Eventuate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../developers.html#building-eventuate">Building Eventuate</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../project.html">Project</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../project.html#community">Community</a></li>
<li class="toctree-l2"><a class="reference internal" href="../project.html#license">License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-does-akka-persistence-compare-to-eventuate">How does Akka Persistence compare to Eventuate?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-can-apache-kafka-be-integrated-with-eventuate">How can Apache Kafka be integrated with Eventuate?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example-application.html">Example application</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../example-application.html#domain">Domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../example-application.html#replication">Replication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../example-application.html#interface">Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../example-application.html#running">Running</a></li>
<li class="toctree-l2"><a class="reference internal" href="../example-application.html#disaster-recovery">Disaster recovery</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../current-limitations.html">Current limitations</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html"><img src="../_static/RedBullMediaHouse-light.png" class="logo" /></a>
      </nav>
 
      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li>
		<a href="../index.html"><h2><span class="breadcrumbicon rbicons topfront"><i class="fa fa-calendar"></i></span>Eventuate</h2></a> &raquo;
	</li>
    
    <li><a href="../reference.html">Reference</a> &raquo;</li>
    
    <li>Event-sourced actors</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="event-sourced-actors">
<span id="ref-event-sourced-actors"></span><h1>Event-sourced actors<a class="headerlink" href="#event-sourced-actors" title="Permalink to this headline">¶</a></h1>
<p>An introduction to event-sourced actors is already given in sections <a class="reference internal" href="../overview.html#overview"><span class="std std-ref">Overview</span></a>, <a class="reference internal" href="../architecture.html#architecture"><span class="std std-ref">Architecture</span></a> and the <a class="reference internal" href="../user-guide.html#user-guide"><span class="std std-ref">User guide</span></a>. Applications use event-sourced actors for writing events to an event log and for maintaining in-memory write models on the command side (C) of a <a class="reference external" href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> application. Event-sourced actors distinguish command processing from event processing. They must extend the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedActor">EventsourcedActor</a> trait and implement a <a class="reference internal" href="#command-handler"><span class="std std-ref">Command handler</span></a> and an <a class="reference internal" href="#event-handler"><span class="std std-ref">Event handler</span></a>.</p>
<div class="section" id="command-handler">
<span id="id1"></span><h2>Command handler<a class="headerlink" href="#command-handler" title="Permalink to this headline">¶</a></h2>
<p>A command handler is partial function of type <code class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></code> for which a type alias <code class="docutils literal"><span class="pre">Receive</span></code> exists. It can be defined by implementing <code class="docutils literal"><span class="pre">onCommand</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.EventsourcedActor</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleCommand</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleCommandSuccess</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleCommandFailure</span><span class="o">(</span><span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="cm">/** Command handler */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ExampleCommand</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="c1">// validate command</span>
      <span class="c1">// ...</span>

      <span class="c1">// derive event</span>
      <span class="k">val</span> <span class="n">event</span> <span class="k">=</span> <span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
      <span class="c1">// persist event (asynchronously)</span>
      <span class="n">persist</span><span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="c1">// success reply</span>
          <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">ExampleCommandSuccess</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cause</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="c1">// failure reply</span>
          <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">ExampleCommandFailure</span><span class="o">(</span><span class="n">cause</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Messages sent by an application to an event-sourced actor are received by its command handler. Usually, a command handler first validates a command, then derives one or more events from it, persists these events with <code class="docutils literal"><span class="pre">persist</span></code> and replies with the persistence result. The <code class="docutils literal"><span class="pre">persist</span></code> method has the following signature<a class="footnote-reference" href="#id16" id="id2">[1]</a>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">persist</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">event</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">customDestinationAggregateIds</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">())(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">persist</span></code> method can be called one ore more times per received command. Calling <code class="docutils literal"><span class="pre">persist</span></code> does not immediately write events to the event log. Instead, events from <code class="docutils literal"><span class="pre">persist</span></code> calls are collected in memory and written to the event log when <code class="docutils literal"><span class="pre">onCommand</span></code> returns.</p>
<p>Events are written asynchronously to the event-sourced actor’s <code class="docutils literal"><span class="pre">eventLog</span></code>. After writing, the <code class="docutils literal"><span class="pre">eventLog</span></code> actor internally replies to the event-sourced actor with a success or failure message which is passed as argument to the persist <code class="docutils literal"><span class="pre">handler</span></code>. Before calling the persist <code class="docutils literal"><span class="pre">handler</span></code>, the event-sourced actor internally calls the <code class="docutils literal"><span class="pre">onEvent</span></code> handler with the written event if writing was successful and <code class="docutils literal"><span class="pre">onEvent</span></code> is defined at that event.</p>
<p>Both, event handler and persist handler are called on a dispatcher thread of the actor. They can therefore safely access internal actor state. The <code class="docutils literal"><span class="pre">sender()</span></code> reference of the original command sender is also preserved, so that a persist handler can reply to the initial command sender.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> trait also defines a <code class="docutils literal"><span class="pre">persistN</span></code> method. Refer to the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedActor">EventsourcedActor</a> API documentation for details.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A command handler should not modify persistent actor state i.e. state that is derived from events.</p>
</div>
</div>
<div class="section" id="state-synchronization">
<span id="state-sync"></span><h2>State synchronization<a class="headerlink" href="#state-synchronization" title="Permalink to this headline">¶</a></h2>
<p>As explained in section <a class="reference internal" href="#command-handler"><span class="std std-ref">Command handler</span></a>, events are persisted asynchronously. What happens if another command is sent to an event-sourced actor while persistence is in progress? This depends on the value of <code class="docutils literal"><span class="pre">stateSync</span></code>, a member of <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> that can be overridden.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">stateSync</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">stateSync</span></code> is <code class="docutils literal"><span class="pre">true</span></code> (default), new commands are <a class="reference external" href="http://doc.akka.io/docs/akka/2.4/scala/actors.html#stash">stashed</a> while persistence is in progress. Consequently, new commands see actor state that is <em>in sync</em> with the events in the event log. A consequence is limited write throughput, because <a class="reference internal" href="../architecture.html#batching"><span class="std std-ref">Batching</span></a> of write requests is not possible in this case<a class="footnote-reference" href="#id17" id="id3">[2]</a>. This setting is recommended for event-sourced actors that must validate commands against current state.</p>
<p>If <code class="docutils literal"><span class="pre">stateSync</span></code> is <code class="docutils literal"><span class="pre">false</span></code>, new commands are dispatched to <code class="docutils literal"><span class="pre">onCommand</span></code> immediately. Consequently, new commands may see stale actor state. The advantage is significantly higher write throughput as <a class="reference internal" href="../architecture.html#batching"><span class="std std-ref">Batching</span></a> of write requests is possible. This setting is recommended for event-sourced actors that don’t need to validate commands against current state.</p>
<p>If a sender sends several (update) commands followed by a query to an event-sourced actor that has <code class="docutils literal"><span class="pre">stateSync</span></code> set to <code class="docutils literal"><span class="pre">false</span></code>, the query will probably not see the state change from the preceding commands. To achieve read-your-write consistency, the command sender should wait for a reply from the last command before sending the query. The reply must of course be sent from within a <code class="docutils literal"><span class="pre">persist</span></code> handler.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">State synchronization settings only apply to a single actor instance. Events that are emitted concurrently by other actors and handled by that instance can arrive at any time and modify actor state. Anyway, concurrent events are not relevant for achieving read-your-write consistency and should be handled as described in the <a class="reference internal" href="../user-guide.html#user-guide"><span class="std std-ref">User guide</span></a>.</p>
</div>
</div>
<div class="section" id="event-handler">
<span id="id4"></span><h2>Event handler<a class="headerlink" href="#event-handler" title="Permalink to this headline">¶</a></h2>
<p>An event handler is partial function of type <code class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></code> for which a type alias <code class="docutils literal"><span class="pre">Receive</span></code> exists. It can be defined by implementing <code class="docutils literal"><span class="pre">onEvent</span></code>. An event handler handles persisted events by updating actor state from event details.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="cm">/** Event handler */</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">details</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">eventSequenceNr</span> <span class="k">=</span> <span class="n">lastSequenceNr</span>
    <span class="k">val</span> <span class="n">eventVectorTimestamp</span> <span class="k">=</span> <span class="n">lastVectorTimestamp</span>
    <span class="c1">// ...</span>

    <span class="c1">// update actor state</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Event metadata of the last handled event can be obtained with the <code class="docutils literal"><span class="pre">last*</span></code> methods defined by <code class="docutils literal"><span class="pre">EventsourcedActor</span></code>. For example, <code class="docutils literal"><span class="pre">lastSequenceNr</span></code> returns the event’s local sequence number, <code class="docutils literal"><span class="pre">lastVectorTimestamp</span></code> returns the event’s vector timestamp. A complete reference is given by the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedActor">EventsourcedActor</a> API documentation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An event handler should only update internal actor state without having further side-effects. An exception is <a class="reference internal" href="#reliable-delivery"><span class="std std-ref">Reliable delivery</span></a> of messages and <a class="reference internal" href="../user-guide.html#guide-event-driven-communication"><span class="std std-ref">Event-driven communication</span></a> with <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.PersistOnEvent">PersistOnEvent</a>.</p>
</div>
</div>
</div>
<div class="section" id="event-sourced-views">
<span id="ref-event-sourced-views"></span><h1>Event-sourced views<a class="headerlink" href="#event-sourced-views" title="Permalink to this headline">¶</a></h1>
<p>An introduction to event-sourced views is already given in sections <a class="reference internal" href="../overview.html#overview"><span class="std std-ref">Overview</span></a>, <a class="reference internal" href="../architecture.html#architecture"><span class="std std-ref">Architecture</span></a> and the <a class="reference internal" href="../user-guide.html#user-guide"><span class="std std-ref">User guide</span></a>. Applications use event-sourced views for for maintaining in-memory read models on the query side (Q) of a <a class="reference external" href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> application.</p>
<p>Like event-sourced actors, event-sourced views distinguish command processing from event processing. They must implement the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedView">EventsourcedView</a> trait. <code class="docutils literal"><span class="pre">EventsourcedView</span></code> is a functional subset of <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> that cannot <code class="docutils literal"><span class="pre">persist</span></code> events.</p>
</div>
<div class="section" id="event-sourced-writers">
<span id="ref-event-sourced-writers"></span><h1>Event-sourced writers<a class="headerlink" href="#event-sourced-writers" title="Permalink to this headline">¶</a></h1>
<p>An introduction to event-sourced writers is already given in sections <a class="reference internal" href="../overview.html#overview"><span class="std std-ref">Overview</span></a> and <a class="reference internal" href="../architecture.html#architecture"><span class="std std-ref">Architecture</span></a>. Applications use event-sourced writers for maintaining persistent read models on the query side (Q) of a <a class="reference external" href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> application.</p>
<p>Like event-sourced views, event-sourced writers can only consume events from an event log but can make incremental batch updates to external, application-defined query databases. A query database can be a relational database, a graph database or whatever is needed by an application. Concrete writers must implement the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedWriter">EventsourcedWriter</a> trait.</p>
<p>This section outlines how to update a persistent read model in <a class="reference external" href="http://cassandra.apache.org/">Cassandra</a> from events consumed by an event-sourced writer. The relevant events are:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">CustomerCreated</span><span class="o">(</span><span class="n">cid</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">first</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">last</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">AddressUpdated</span><span class="o">(</span><span class="n">cid</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
<p>The persistent read model is a <code class="docutils literal"><span class="pre">CUSTOMER</span></code> table with the following structure:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span> <span class="n">id</span> <span class="o">|</span> <span class="n">first</span>  <span class="o">|</span> <span class="n">last</span>    <span class="o">|</span> <span class="n">address</span>
<span class="o">----+--------+---------+-------------</span>
  <span class="mi">1</span> <span class="o">|</span> <span class="nc">Martin</span> <span class="o">|</span> <span class="nc">Krasser</span> <span class="o">|</span> <span class="nc">Somewhere</span> <span class="mi">1</span>
  <span class="mi">2</span> <span class="o">|</span> <span class="nc">Volker</span> <span class="o">|</span> <span class="nc">Stampa</span>  <span class="o">|</span> <span class="nc">Somewhere</span> <span class="mi">3</span>
  <span class="mi">3</span> <span class="o">|</span> <span class="o">...</span>    <span class="o">|</span> <span class="o">...</span>     <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>The read model update progress is written to a separate <code class="docutils literal"><span class="pre">PROGRESS</span></code> table with a single <code class="docutils literal"><span class="pre">sequence_nr</span></code> column:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span> <span class="n">id</span> <span class="o">|</span> <span class="n">sequence_nr</span>
<span class="o">----+-------------</span>
  <span class="mi">0</span> <span class="o">|</span>           <span class="mi">3</span>
</pre></div>
</div>
<p>The stored sequence number is that of the last successfully processed event. An event is considered as successfully processed if its data have been written to the <code class="docutils literal"><span class="pre">CUSTOMER</span></code> table. Only a single row is needed in the <code class="docutils literal"><span class="pre">PROGRESS</span></code> table to track the update progress for the whole <code class="docutils literal"><span class="pre">CUSTOMER</span></code> table.</p>
<p>The event-sourced <code class="docutils literal"><span class="pre">Writer</span></code> in the following example implements <code class="docutils literal"><span class="pre">EventsourcedWriter[Long,</span> <span class="pre">Unit]</span></code> (where <code class="docutils literal"><span class="pre">Long</span></code> is the type of the initial read result and <code class="docutils literal"><span class="pre">Unit</span></code> the type of write results). It is initialized with an <code class="docutils literal"><span class="pre">eventLog</span></code> from which it consumes events and a Cassandra <code class="docutils literal"><span class="pre">Session</span></code> for writing event processing results.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.lang.</span><span class="o">{</span> <span class="nc">Long</span> <span class="k">=&gt;</span> <span class="nc">JLong</span> <span class="o">}</span>

<span class="k">import</span> <span class="nn">akka.actor.ActorRef</span>

<span class="k">import</span> <span class="nn">com.datastax.driver.core._</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.EventsourcedWriter</span>

<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="cm">/**</span>
<span class="cm"> * Processes `CustomerCreated` and `AddressUpdated` events and updates</span>
<span class="cm"> * a `CUSTOMER` table in Cassandra with incremental batches.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Writer</span><span class="o">(</span><span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">session</span><span class="k">:</span> <span class="kt">Session</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">EventsourcedWriter</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">Writer._</span>
  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="k">val</span> <span class="n">insertCustomerStmt</span> <span class="k">=</span> <span class="n">session</span><span class="o">.</span><span class="n">prepare</span><span class="o">(</span>
    <span class="s">&quot;INSERT INTO CUSTOMER (id, first, last, address) VALUES (?, ?, ?, ?)&quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">updateCustomerStmt</span> <span class="k">=</span> <span class="n">session</span><span class="o">.</span><span class="n">prepare</span><span class="o">(</span>
    <span class="s">&quot;UPDATE CUSTOMER SET address = ? WHERE id = ?&quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">updateProgressStmt</span> <span class="k">=</span> <span class="n">session</span><span class="o">.</span><span class="n">prepare</span><span class="o">(</span>
    <span class="s">&quot;UPDATE PROGRESS SET sequence_nr = ? WHERE id = 0&quot;</span><span class="o">)</span>

  <span class="cm">/**</span>
<span class="cm">   * Batch of Cassandra update statements collected during event processing.</span>
<span class="cm">   */</span>
  <span class="k">var</span> <span class="n">batch</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">BoundStatement</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="cm">/**</span>
<span class="cm">   * Suspends replay after 16 events, triggers a `write` and then continues</span>
<span class="cm">   * with the next 16 events. This is implements event replay backpressure,</span>
<span class="cm">   * needed if writing to the database is slower than replaying from the</span>
<span class="cm">   * `eventLog` (which is usually the case).</span>
<span class="cm">   */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">replayBatchSize</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="mi">16</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Prepares an update `batch` from handled events that is written to the</span>
<span class="cm">   * database when `write` is called. An event handler never writes to the</span>
<span class="cm">   * database directly.</span>
<span class="cm">   */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">c</span> <span class="k">@</span> <span class="nc">CustomerCreated</span><span class="o">(</span><span class="n">cid</span><span class="o">,</span> <span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">batch</span> <span class="k">=</span> <span class="n">batch</span> <span class="o">:+</span> <span class="n">insertCustomerStmt</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">cid</span><span class="k">:</span> <span class="kt">JLong</span><span class="o">,</span> <span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">u</span> <span class="k">@</span> <span class="nc">AddressUpdated</span><span class="o">(</span><span class="n">cid</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">batch</span> <span class="k">=</span> <span class="n">batch</span> <span class="o">:+</span> <span class="n">updateCustomerStmt</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">cid</span><span class="k">:</span> <span class="kt">JLong</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Asynchronously writes the prepared update `batch` to the database</span>
<span class="cm">   * together with the sequence number of the last processed event. After</span>
<span class="cm">   * having submitted the batch, it is cleared so that further events can</span>
<span class="cm">   * be processed while the write is in progress.</span>
<span class="cm">   */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">write</span><span class="o">()</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">snr</span> <span class="k">=</span> <span class="n">lastSequenceNr</span>
    <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">batch</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">stmt</span> <span class="k">=&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">executeAsync</span><span class="o">(</span><span class="n">stmt</span><span class="o">).</span><span class="n">toFuture</span><span class="o">))</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">session</span><span class="o">.</span><span class="n">executeAsync</span><span class="o">(</span><span class="n">updateProgressStmt</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">snr</span><span class="k">:</span> <span class="kt">JLong</span><span class="o">)).</span><span class="n">toFuture</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
    <span class="n">batch</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span> <span class="c1">// clear batch</span>
    <span class="n">res</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Reads the sequence number of the last update. This method is called only</span>
<span class="cm">   * once during writer initialization (after start or restart).</span>
<span class="cm">   */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">read</span><span class="o">()</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">session</span><span class="o">.</span><span class="n">executeAsync</span><span class="o">(</span><span class="s">&quot;SELECT sequence_nr FROM PROGRESS WHERE id = 0&quot;</span><span class="o">).</span><span class="n">toFuture</span>
      <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">isExhausted</span><span class="o">)</span> <span class="mi">0L</span> <span class="k">else</span> <span class="n">rs</span><span class="o">.</span><span class="n">one</span><span class="o">().</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Handles the `read` result by returning the read value + 1, indicating the</span>
<span class="cm">   * start position for further reads from the event log.</span>
<span class="cm">   */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">readSuccess</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="mi">1L</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Writer</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">java.util.concurrent.Executor</span>

  <span class="k">import</span> <span class="nn">com.google.common.util.concurrent.ListenableFuture</span>

  <span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span> <span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Promise</span> <span class="o">}</span>
  <span class="k">import</span> <span class="nn">scala.language.implicitConversions</span>
  <span class="k">import</span> <span class="nn">scala.util.Try</span>

  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ListenableFutureConverter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lf</span><span class="k">:</span> <span class="kt">ListenableFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">executionContext</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">toFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">promise</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
      <span class="n">lf</span><span class="o">.</span><span class="n">addListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="n">promise</span><span class="o">.</span><span class="n">complete</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">lf</span><span class="o">.</span><span class="n">get</span><span class="o">()))</span>
      <span class="o">},</span> <span class="n">executionContext</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Executor</span><span class="o">])</span>
      <span class="n">promise</span><span class="o">.</span><span class="n">future</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The full example source code is available <a class="reference external" href="https://github.com/RBMHTechnology/eventuate/tree/master/eventuate-examples/src/main/scala/com/rbmhtechnology/example/querydb">here</a>.</p>
</div>
<p>On a high level, the example <code class="docutils literal"><span class="pre">Writer</span></code> implements the following behavior:</p>
<ul class="simple">
<li>During initialization (after start or restart) it asynchronously <code class="docutils literal"><span class="pre">read</span></code>s the stored update progress from the <code class="docutils literal"><span class="pre">PROGRESS</span></code> table. The read result is passed as argument to <code class="docutils literal"><span class="pre">readSuccess</span></code> and incremented by <code class="docutils literal"><span class="pre">1</span></code> before returning it to the caller. This causes the <code class="docutils literal"><span class="pre">Writer</span></code> to resume event processing from that position in the event log.</li>
<li>Event are processed in <code class="docutils literal"><span class="pre">onEvent</span></code> by translating them to Cassandra update statements which are added to an in-memory <code class="docutils literal"><span class="pre">batch</span></code> of type <code class="docutils literal"><span class="pre">Vector[BoundStatement]</span></code>. The batch is written to Cassandra when Eventuate calls the <code class="docutils literal"><span class="pre">write</span></code> method.</li>
<li>The <code class="docutils literal"><span class="pre">write</span></code> method asynchronously updates the <code class="docutils literal"><span class="pre">CUSTOMER</span></code> table with the statements contained in <code class="docutils literal"><span class="pre">batch</span></code> and then updates the <code class="docutils literal"><span class="pre">PROGRESS</span></code> table with the sequence number of the last processed event. After having submitted the statements to Cassandra, the batch is cleared for further event processing. Event processing can run concurrently to write operations.</li>
<li>A <code class="docutils literal"><span class="pre">batch</span></code> that has been updated while a write operation is in progress is written directly after the current write operation successfully completes. If no write operation is in progress, a change to <code class="docutils literal"><span class="pre">batch</span></code> is written immediately. This keeps read model update delays at a minimum and increases batch sizes under increasing load. Batch sizes can be limited with <code class="docutils literal"><span class="pre">replayBatchSize</span></code>.</li>
</ul>
<p>If a <code class="docutils literal"><span class="pre">write</span></code> (or <code class="docutils literal"><span class="pre">read</span></code>) operation fails, the writer is restarted, by default, and resumes event processing from the last stored sequence number + <code class="docutils literal"><span class="pre">1</span></code>. This behavior can be changed by overriding <code class="docutils literal"><span class="pre">writeFailure</span></code> (or <code class="docutils literal"><span class="pre">readFailure</span></code>) from <code class="docutils literal"><span class="pre">EventsourcedWriter</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The example does not use Cassandra <code class="docutils literal"><span class="pre">BatchStatement</span></code>s for reasons explained in <a class="reference external" href="https://medium.com/&#64;foundev/cassandra-batch-loading-without-the-batch-keyword-40f00e35e23e">this article</a>. Atomic writes are not needed because database updates in this example are idempotent and can be re-tried in failure cases. Failure cases where idempotency is relevant are partial updates to the <code class="docutils literal"><span class="pre">CUSTOMER</span></code> table or a failed write to the <code class="docutils literal"><span class="pre">PROGRESS</span></code> table. <code class="docutils literal"><span class="pre">BatchStatement</span></code>s should only be used when database updates are not idempotent and atomicity is required on database level.</p>
</div>
<div class="section" id="stateful-writers">
<span id="id5"></span><h2>Stateful writers<a class="headerlink" href="#stateful-writers" title="Permalink to this headline">¶</a></h2>
<p>The above <code class="docutils literal"><span class="pre">Writer</span></code> implements a stateless writer. Although it accumulates batches while a write operation is in progress, it cannot recover permanent in-memory state from the event log, because event processing only starts from the last stored sequence number. If a writer needs to be stateful, it must return <code class="docutils literal"><span class="pre">None</span></code> from <code class="docutils literal"><span class="pre">readSuccess</span></code>. In this case, event replay either starts from scratch or from a previously stored snapshot. A stateful writer should still write the update progress to the <code class="docutils literal"><span class="pre">PROGRESS</span></code> table but exclude events with a sequence number less than or equal to the stored sequence number from contributing to the update <code class="docutils literal"><span class="pre">batch</span></code>.</p>
</div>
</div>
<div class="section" id="event-sourced-processors">
<span id="ref-event-sourced-processors"></span><h1>Event-sourced processors<a class="headerlink" href="#event-sourced-processors" title="Permalink to this headline">¶</a></h1>
<p>An introduction to event-sourced processors is already given in sections <a class="reference internal" href="../overview.html#overview"><span class="std std-ref">Overview</span></a> and <a class="reference internal" href="../architecture.html#architecture"><span class="std std-ref">Architecture</span></a>. Applications use event-sourced processors to consume events form a source event log, process these events and write the processed events to a target event log. With processors, event logs can be connected to event stream processing pipelines and graphs.</p>
<p>Event-sourced processors are a specialization of <a class="reference internal" href="../architecture.html#event-sourced-writers"><span class="std std-ref">Event-sourced writers</span></a> where the <em>external database</em> is a target event log. Concrete stateless processors must implement the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.EventsourcedProcessor">EventsourcedProcessor</a> trait, stateful processors the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.StatefulProcessor">StatefulProcessor</a> trait (see also <a class="reference internal" href="#stateful-writers"><span class="std std-ref">Stateful writers</span></a>).</p>
<p>The following example <code class="docutils literal"><span class="pre">Processor</span></code> is an implementation of <code class="docutils literal"><span class="pre">EventsourcedProcessor</span></code>. In addition to providing a source <code class="docutils literal"><span class="pre">eventLog</span></code>, a concrete processor must also provide a <code class="docutils literal"><span class="pre">targetEventLog</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span>
    <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span>
    <span class="k">val</span> <span class="n">targetEventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">EventsourcedProcessor</span> <span class="o">{</span>
  <span class="c1">// ...</span>

  <span class="k">override</span> <span class="k">val</span> <span class="n">processEvent</span><span class="k">:</span> <span class="kt">Process</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// exclude event</span>
    <span class="k">case</span> <span class="s">&quot;my-event-1&quot;</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="c1">// transform event</span>
    <span class="k">case</span> <span class="s">&quot;my-event-2&quot;</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&quot;my-event-2a&quot;</span><span class="o">)</span>
    <span class="c1">// transform and split event</span>
    <span class="k">case</span> <span class="s">&quot;my-event-3&quot;</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&quot;my-event-3a&quot;</span><span class="o">,</span> <span class="s">&quot;my-event-3b&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The event handler implemented by a processor is <code class="docutils literal"><span class="pre">processEvent</span></code>. The type of the handler is defined as:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Process</span> <span class="o">=</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span>
</pre></div>
</div>
<p>Processed events, to be written to the target event log, are returned by the handler as <code class="docutils literal"><span class="pre">Seq[Any]</span></code>. With this handler signature, events from the source log can be</p>
<ul class="simple">
<li>excluded from being written to the target log by returning an empty <code class="docutils literal"><span class="pre">Seq</span></code></li>
<li>transformed one-to-one by returning a <code class="docutils literal"><span class="pre">Seq</span></code> of size 1 or even</li>
<li>transformed and split by returning a <code class="docutils literal"><span class="pre">Seq</span></code> of size greater than <code class="docutils literal"><span class="pre">1</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">EventsourcedProcessor</span></code> and <code class="docutils literal"><span class="pre">StatefulProcessor</span></code> internally ensure that writing to the target event log is idempotent. Applications don’t need to take extra care about idempotency.</p>
</div>
</div>
<div class="section" id="state-recovery">
<span id="id6"></span><h1>State recovery<a class="headerlink" href="#state-recovery" title="Permalink to this headline">¶</a></h1>
<p>When an event-sourced actor or view is started or re-started, events are replayed to its <code class="docutils literal"><span class="pre">onEvent</span></code> handler so that internal state can be recovered<a class="footnote-reference" href="#id18" id="id7">[3]</a>. This is also the case for stateful event-sourced writers and processors. During event replay the <code class="docutils literal"><span class="pre">recovering</span></code> method returns <code class="docutils literal"><span class="pre">true</span></code>. Applications can also define a recovery completion handler by overriding <code class="docutils literal"><span class="pre">onRecovery</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>
<span class="c1">// ...</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onRecovery</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If replay fails the completion handler is called with a <code class="docutils literal"><span class="pre">Failure</span></code> and the actor will be stopped, regardless of the action taken by the handler. The default recovery completion handler does nothing.</p>
<p>At the beginning of event replay, the initiating actor is registered at its event log so that newly written events can be routed to that actor. During replay, the actor internally stashes these newly written events and dispatches them to <code class="docutils literal"><span class="pre">onEvent</span></code> after successful replay. In a similar way, the actor also stashes new commands and dispatches them to <code class="docutils literal"><span class="pre">onCommand</span></code> afterwards. This ensures that new commands never see partially recovered state. When the actor is stopped it is automatically de-registered from its event log.</p>
<div class="section" id="backpressure">
<h2>Backpressure<a class="headerlink" href="#backpressure" title="Permalink to this headline">¶</a></h2>
<p>Events are replayed in batches. A given batch must have been handled by an event handler before the next batch is replayed. This allows slow event handlers to put backpressure on event replay. The default replay batch size can be configured with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">replay</span><span class="o">-</span><span class="n">batch</span><span class="o">-</span><span class="n">size</span> <span class="k">=</span> <span class="mi">4096</span>
</pre></div>
</div>
<p>Event-sourced components can override the configured default value by overriding <code class="docutils literal"><span class="pre">replayBatchSize</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">replayBatchSize</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">64</span>

  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recovery-using-an-application-defined-log-sequence-number">
<span id="snapshots"></span><h2>Recovery using an application-defined log sequence number<a class="headerlink" href="#recovery-using-an-application-defined-log-sequence-number" title="Permalink to this headline">¶</a></h2>
<p>In order to keep recovery times small it is almost always sensible to recover using snapshots. However, in some very rare cases an event-sourced actor or view can recover quickly using an application-defined log sequence number. If defined, only events with a sequence number equal to or larger than the given sequence number are replayed.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomRecoveryExampleActor</span><span class="o">(</span><span class="n">snr</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">replayFromSequenceNr</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">snr</span><span class="o">)</span>

  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h1>Snapshots<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h1>
<p>Recovery times increase with the number of events that are replayed to event-sourced components. They can be decreased by starting event replay from a previously saved snapshot of internal state rather than replaying events from scratch. Event-sourced components can save snapshots by calling <code class="docutils literal"><span class="pre">save</span></code> within their command handler:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.EventsourcedActor</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.SnapshotMetadata</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Save</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">SaveSuccess</span><span class="o">(</span><span class="n">metadata</span><span class="k">:</span> <span class="kt">SnapshotMetadata</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">SaveFailure</span><span class="o">(</span><span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleState</span><span class="o">(</span><span class="n">components</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">ExampleState</span> <span class="o">=</span> <span class="nc">ExampleState</span><span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Save</span> <span class="k">=&gt;</span>
      <span class="c1">// save snapshot of internal state (asynchronously)</span>
      <span class="n">save</span><span class="o">(</span><span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">metadata</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="c1">// success reply</span>
          <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">SaveSuccess</span><span class="o">(</span><span class="n">metadata</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cause</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="c1">// failure reply</span>
          <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">SaveFailure</span><span class="o">(</span><span class="n">cause</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="n">cmd</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">evt</span> <span class="k">=&gt;</span> <span class="c1">// update state ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Snapshots are saved asynchronously. On completion, a user-defined handler of type <code class="docutils literal"><span class="pre">Try[SnapshotMetadata]</span> <span class="pre">=&gt;</span> <span class="pre">Unit</span></code> is called. Like a <code class="docutils literal"><span class="pre">persist</span></code> handler, a <code class="docutils literal"><span class="pre">save</span></code> handler may also close over actor state and can reply to the command sender using the <code class="docutils literal"><span class="pre">sender()</span></code> reference.</p>
<p>An event-sourced actor that is <a class="reference internal" href="../user-guide.html#tracking-conflicting-versions"><span class="std std-ref">Tracking conflicting versions</span></a> of application state can also save <code class="docutils literal"><span class="pre">ConcurrentVersions[A,</span> <span class="pre">B]</span></code> instances directly. One can even configure custom serializers for type parameter <code class="docutils literal"><span class="pre">A</span></code> as explained in section <a class="reference internal" href="#snapshot-serialization"><span class="std std-ref">Custom snapshot serialization</span></a>.</p>
<p>During recovery, the latest snapshot saved by an event-sourced component is loaded and can be handled with the <code class="docutils literal"><span class="pre">onSnapshot</span></code> handler. This handler should initialize internal actor state from the loaded snapshot:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">ExampleState</span> <span class="o">=</span> <span class="nc">ExampleState</span><span class="o">()</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Save</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
    <span class="k">case</span> <span class="n">cmd</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">evt</span> <span class="k">=&gt;</span> <span class="c1">// update state ...</span>
  <span class="o">}</span>

  <span class="cm">/** Snapshot handler */</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onSnapshot</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">ExampleState</span> <span class="o">=&gt;</span>
      <span class="c1">// initialize internal state from loaded snapshot</span>
      <span class="n">state</span> <span class="k">=</span> <span class="n">s</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">onSnapshot</span></code> is not defined at the loaded snapshot or not overridden at all, event replay starts from scratch. If <code class="docutils literal"><span class="pre">onSnapshot</span></code> is defined at the loaded snapshot, only events that are not covered by that snapshot will be replayed.</p>
<p>Event-sourced actors that implement <code class="docutils literal"><span class="pre">ConfirmedDelivery</span></code> for <a class="reference internal" href="#reliable-delivery"><span class="std std-ref">Reliable delivery</span></a> automatically include unconfirmed messages into state snapshots. These are restored on recovery and re-delivered on recovery completion.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">State objects passed as argument to <code class="docutils literal"><span class="pre">save</span></code> should be <em>immutable objects</em>. If this is not the case, the caller is responsible for creating a defensive copy before passing it as argument to <code class="docutils literal"><span class="pre">save</span></code>.</p>
</div>
<div class="section" id="storage-locations">
<h2>Storage locations<a class="headerlink" href="#storage-locations" title="Permalink to this headline">¶</a></h2>
<p>Snapshots are currently stored in a directory that can be configured with</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">snapshot</span><span class="o">.</span><span class="n">filesystem</span><span class="o">.</span><span class="n">dir</span> <span class="k">=</span> <span class="o">/</span><span class="n">my</span><span class="o">/</span><span class="n">storage</span><span class="o">/</span><span class="n">location</span>
</pre></div>
</div>
<p>in <code class="docutils literal"><span class="pre">application.conf</span></code>. The maximum number of stored snapshots per event-sourced component can be configured with</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">snapshot</span><span class="o">.</span><span class="n">filesystem</span><span class="o">.</span><span class="n">snapshots</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">emitter</span><span class="o">-</span><span class="n">max</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>If this number is exceeded, older snapshots are automatically deleted.</p>
</div>
</div>
<div class="section" id="event-routing">
<span id="id9"></span><h1>Event routing<a class="headerlink" href="#event-routing" title="Permalink to this headline">¶</a></h1>
<p>An event that is emitted by an event-sourced actor or processor can be routed to other event-sourced components if they share an <a class="reference internal" href="event-log.html#event-log"><span class="std std-ref">Event log</span></a><a class="footnote-reference" href="#id19" id="id10">[4]</a> . The default event routing rules are:</p>
<ul class="simple">
<li>If an event-sourced component has an undefined <code class="docutils literal"><span class="pre">aggregateId</span></code>, all events are routed to it. It may choose to handle only a subset of them though.</li>
<li>If an event-sourced component has a defined <code class="docutils literal"><span class="pre">aggregateId</span></code>, only events emitted by event-sourced actors or processors with the same <code class="docutils literal"><span class="pre">aggregateId</span></code> are routed to it.</li>
</ul>
<p>Routing destinations are defined during emission of an event and are persisted together with the event<a class="footnote-reference" href="#id20" id="id11">[5]</a>. This makes routing decisions repeatable during event replay and allows for routing rule changes without affecting past routing decisions. Applications can define additional routing destinations with the <code class="docutils literal"><span class="pre">customDestinationAggregateIds</span></code> parameter of <code class="docutils literal"><span class="pre">persist</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.EventsourcedActor</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ExampleCommand</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">aggregateId</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;a1&quot;</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ExampleCommand</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">persist</span><span class="o">(</span><span class="nc">ExampleEvent</span><span class="o">(</span><span class="n">data</span><span class="o">),</span> <span class="n">customDestinationAggregateIds</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;a2&quot;</span><span class="o">,</span> <span class="s">&quot;a3&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="c1">// ...</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cause</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">ExampleEvent</span></code> is routed to destinations with <code class="docutils literal"><span class="pre">aggregateId</span></code>s <code class="docutils literal"><span class="pre">Some(“a2”)</span></code> and <code class="docutils literal"><span class="pre">Some(“a3”)</span></code> in addition to the default routing destinations with <code class="docutils literal"><span class="pre">aggregateId</span></code>s <code class="docutils literal"><span class="pre">Some(“a1”)</span></code> and <code class="docutils literal"><span class="pre">None</span></code>.</p>
</div>
<div class="section" id="event-driven-communication">
<span id="ref-event-driven-communication"></span><h1>Event-driven communication<a class="headerlink" href="#event-driven-communication" title="Permalink to this headline">¶</a></h1>
<p>Event-driven communication is one form of <a class="reference internal" href="../overview.html#overview-event-collaboration"><span class="std std-ref">Event collaboration</span></a> and covered in the <a class="reference internal" href="../user-guide.html#guide-event-driven-communication"><span class="std std-ref">Event-driven communication</span></a> section of the <a class="reference internal" href="../user-guide.html#user-guide"><span class="std std-ref">User guide</span></a>.</p>
</div>
<div class="section" id="reliable-delivery">
<span id="id12"></span><h1>Reliable delivery<a class="headerlink" href="#reliable-delivery" title="Permalink to this headline">¶</a></h1>
<p>Reliable, event-based remote communication between event-sourced actors should be done via a <a class="reference internal" href="event-log.html#replicated-event-log"><span class="std std-ref">Replicated event log</span></a>. For reliable communication with other services that cannot connect to a replicated event log, event-sourced actors should use the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.ConfirmedDelivery">ConfirmedDelivery</a> trait:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.util._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.EventsourcedActor</span>
<span class="k">import</span> <span class="nn">com.rbmhtechnology.eventuate.ConfirmedDelivery</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DeliverCommand</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">DeliverEvent</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Confirmation</span><span class="o">(</span><span class="n">deliveryId</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ConfirmationEvent</span><span class="o">()</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ReliableMessage</span><span class="o">(</span><span class="n">deliveryId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Redeliver</span>

<span class="k">class</span> <span class="nc">ExampleActor</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorPath</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                   <span class="k">override</span> <span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="k">with</span> <span class="nc">ConfirmedDelivery</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span>
    <span class="n">initialDelay</span> <span class="k">=</span> <span class="mf">10.</span><span class="n">seconds</span><span class="o">,</span>
    <span class="n">interval</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">,</span>
    <span class="n">receiver</span> <span class="k">=</span> <span class="n">self</span><span class="o">,</span>
    <span class="n">message</span> <span class="k">=</span> <span class="nc">Redeliver</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">DeliverCommand</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">persist</span><span class="o">(</span><span class="nc">DeliverEvent</span><span class="o">(</span><span class="n">message</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="nc">Confirmation</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span> <span class="k">if</span> <span class="n">unconfirmed</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">persistConfirmation</span><span class="o">(</span><span class="nc">ConfirmationEvent</span><span class="o">(),</span> <span class="n">deliveryId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="nc">Redeliver</span> <span class="k">=&gt;</span>
      <span class="n">redeliverUnconfirmed</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">DeliverEvent</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">deliveryId</span> <span class="k">=</span> <span class="n">lastSequenceNr</span><span class="o">.</span><span class="n">toString</span>
        <span class="n">deliver</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">,</span> <span class="nc">ReliableMessage</span><span class="o">(</span><span class="n">deliveryId</span><span class="o">,</span> <span class="n">message</span><span class="o">),</span> <span class="n">destination</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">ConfirmationEvent</span><span class="o">()</span> <span class="k">=&gt;</span>
        <span class="c1">// handling of confirmation event is optional</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ConfirmedDelivery</span></code> supports the reliable delivery of messages to destinations by enabling applications to re-deliver messages until delivery is confirmed by destinations. In the example above, the reliable delivery of a message is initiated by sending a <code class="docutils literal"><span class="pre">DeliverCommand</span></code> to <code class="docutils literal"><span class="pre">ExampleActor</span></code>.</p>
<p>The handler of the generated <code class="docutils literal"><span class="pre">DeliverEvent</span></code> calls <code class="docutils literal"><span class="pre">deliver</span></code> to deliver a <code class="docutils literal"><span class="pre">ReliableMessage</span></code> to <code class="docutils literal"><span class="pre">destination</span></code>. The <code class="docutils literal"><span class="pre">deliveryId</span></code> is an identifier to correlate <code class="docutils literal"><span class="pre">ReliableMessage</span></code> with a <code class="docutils literal"><span class="pre">Confirmation</span></code> message. The <code class="docutils literal"><span class="pre">deliveryId</span></code> can be any application-defined id. Here, the event’s sequence number is used which can be obtained with <code class="docutils literal"><span class="pre">lastSequenceNumber</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">destination</span></code> confirms the delivery of the message by sending a <code class="docutils literal"><span class="pre">Confirmation</span></code> reply to the event-sourced actor from which it generates a <code class="docutils literal"><span class="pre">ConfirmationEvent</span></code>. The actor uses the <code class="docutils literal"><span class="pre">persistConfirmation</span></code> method to persist the confirmation event together with the delivery id. After successful persistence of the confirmation event, the corresponding reliable message is removed from the internal buffer of unconfirmed messages.</p>
<p>When the actor is re-started, unconfirmed reliable messages are automatically re-delivered to their <code class="docutils literal"><span class="pre">destination</span></code>s. The example actor additionally schedules <code class="docutils literal"><span class="pre">redeliverUnconfirmed</span></code> calls to periodically re-deliver unconfirmed messages. This is done within the actor’s command handler.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the above example a pattern guard is used for idempotent confirmation processing by ensuring that the <code class="docutils literal"><span class="pre">deliveryId</span></code> of the <code class="docutils literal"><span class="pre">Confirmation</span></code> message is still unconfirmed. This pattern may only be applied if the <code class="docutils literal"><span class="pre">stateSync</span></code> member of the <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> is set to <code class="docutils literal"><span class="pre">true</span></code>. For further details on <code class="docutils literal"><span class="pre">stateSync</span></code> see section <a class="reference internal" href="#state-sync"><span class="std std-ref">State synchronization</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a snapshot is taken unconfirmed messages are stored in the snapshot along with the destination <code class="docutils literal"><span class="pre">ActorPath</span></code>. That is why the actual <code class="docutils literal"><span class="pre">ActorPath</span></code> of the destination must not change between restarts of the actor, if, for example, the destination actor is within the same application and the application is restarted. That is why the destination actor must be named explicitly instead of having a name generated by the <code class="docutils literal"><span class="pre">ActorSystem</span></code>.</p>
</div>
</div>
<div class="section" id="conditional-requests">
<span id="ref-conditional-requests"></span><h1>Conditional requests<a class="headerlink" href="#conditional-requests" title="Permalink to this headline">¶</a></h1>
<p>Conditional requests are covered in the <a class="reference internal" href="../user-guide.html#conditional-requests"><span class="std std-ref">Conditional requests</span></a> section of the <a class="reference internal" href="../user-guide.html#user-guide"><span class="std std-ref">User guide</span></a>.</p>
</div>
<div class="section" id="command-stashing">
<span id="id13"></span><h1>Command stashing<a class="headerlink" href="#command-stashing" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">EventsourcedView</span></code> and <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> override <code class="docutils literal"><span class="pre">stash()</span></code> and <code class="docutils literal"><span class="pre">unstashAll()</span></code> of <code class="docutils literal"><span class="pre">akka.actor.Stash</span></code> so that application-specific subclasses can safely stash and unstash commands. Stashing of events is not allowed. Hence, <code class="docutils literal"><span class="pre">stash()</span></code> must only be used in a command handler, using it in an event handler will throw <code class="docutils literal"><span class="pre">StashError</span></code>. On the other hand, <code class="docutils literal"><span class="pre">unsatshAll()</span></code> can be used anywhere i.e. in a command handler, persist handler or event handler. The following is a trivial usage example which calls <code class="docutils literal"><span class="pre">stash()</span></code> in the command handler and <code class="docutils literal"><span class="pre">unstashAll()</span></code> in the persist handler:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">CreateUser</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UpdateUser</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserEvent</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UserCreated</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserEvent</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserUpdated</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserEvent</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">UserManager</span><span class="o">(</span><span class="k">val</span> <span class="n">eventLog</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">users</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">override</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="s">&quot;example&quot;</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">CreateUser</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">persistUserEvent</span><span class="o">(</span><span class="nc">UserCreated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">),</span> <span class="n">unstashAll</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">UpdateUser</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">if</span> <span class="n">users</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="c1">// UpdateUser received after CreateUser</span>
      <span class="n">persistUserEvent</span><span class="o">(</span><span class="nc">UserUpdated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">UpdateUser</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="c1">// UpdateUser received before CreateUser</span>
      <span class="n">stash</span><span class="o">()</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UserCreated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">users</span> <span class="k">=</span> <span class="n">users</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="nc">User</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">UserUpdated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">users</span> <span class="k">=</span> <span class="n">users</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="nc">User</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">persistUserEvent</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">UserEvent</span><span class="o">,</span> <span class="n">onSuccess</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="o">())</span> <span class="k">=</span>
    <span class="n">persist</span><span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">evt</span>
        <span class="n">onSuccess</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">err</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">UserManager</span></code> maintains a persistent <code class="docutils literal"><span class="pre">users</span></code> map. User can be added to the map by sending a <code class="docutils literal"><span class="pre">CreateUser</span></code> command and updated by sending and <code class="docutils literal"><span class="pre">UpdateUser</span></code> command. Should these commands arrive in wrong order i.e. <code class="docutils literal"><span class="pre">UpdateUser</span></code> before a corresponding <code class="docutils literal"><span class="pre">CreateUser</span></code>, the <code class="docutils literal"><span class="pre">UserManager</span></code> stashes <code class="docutils literal"><span class="pre">UpdateUser</span></code> and unstashes it after having successfully processed another <code class="docutils literal"><span class="pre">CreateUser</span></code> command.</p>
<p>In the above implementation, an <code class="docutils literal"><span class="pre">UpdateUser</span></code> command might be repeatedly stashed and unstashed if the corresponding <code class="docutils literal"><span class="pre">CreateUser</span></code> command is preceded by other unrelated <code class="docutils literal"><span class="pre">CreateUser</span></code> commands. Assuming that out-of-order user commands are rare, the performance impact is limited. Alternatively, one could record stashed user ids in transient actor state and conditionally call <code class="docutils literal"><span class="pre">unstashAll()</span></code> by checking that state.</p>
</div>
<div class="section" id="behavior-changes">
<h1>Behavior changes<a class="headerlink" href="#behavior-changes" title="Permalink to this headline">¶</a></h1>
<p>Event-sourced components distinguish command processing from event processing. Consequently, applications should be able to change the behavior of command handlers and event handlers independent of each other, at runtime. Command handling behavior can be changed with <code class="docutils literal"><span class="pre">commandContext.become()</span></code> and <code class="docutils literal"><span class="pre">commandContext.unbecome()</span></code>, event handling behavior with <code class="docutils literal"><span class="pre">eventContext.become()</span></code> and <code class="docutils literal"><span class="pre">eventContext.unbecome()</span></code> (for details, see the <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.BehaviorContext">BehaviorContext</a> API docs):</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">ExampleActor</span> <span class="k">extends</span> <span class="nc">EventsourcedActor</span> <span class="o">{</span>
  <span class="c1">// default command handler</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;a&quot;</span> <span class="k">=&gt;</span> <span class="n">commandContext</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">newCommandHandler</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// default event handler</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;x&quot;</span> <span class="k">=&gt;</span> <span class="n">eventContext</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">newEventHandler</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">newCommandHandler</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;b&quot;</span> <span class="k">=&gt;</span>
      <span class="c1">// restores default command handler</span>
      <span class="n">commandContext</span><span class="o">.</span><span class="n">unbecome</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">newEventHandler</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;y&quot;</span> <span class="k">=&gt;</span>
      <span class="c1">// restores default event handler</span>
      <span class="n">eventContext</span><span class="o">.</span><span class="n">unbecome</span><span class="o">()</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>This works for all event-sourcing abstractions except for <code class="docutils literal"><span class="pre">EventsourcedProcessor</span></code>. Its <code class="docutils literal"><span class="pre">eventContext</span></code> does not allow behavior changes as <code class="docutils literal"><span class="pre">EventsourcedProcessor</span></code> implements default <code class="docutils literal"><span class="pre">onEvent</span></code> behavior that should be changed by applications. An attempt to change that behavior will throw an <code class="docutils literal"><span class="pre">UnsupportedOperationException</span></code>. Changing an <code class="docutils literal"><span class="pre">EventsourcedProcessor</span></code>’s <code class="docutils literal"><span class="pre">processEvent</span></code> behavior is not supported yet.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Command and event handling behaviors are managed by internal behavior stacks. Eventuate does <strong>not</strong> include these behavior stacks into <a class="reference internal" href="#snapshots"><span class="std std-ref">Recovery using an application-defined log sequence number</span></a> when applications <code class="docutils literal"><span class="pre">save</span></code> actor state. Although the state of an event handling behavior stack can be recovered by replaying events from scratch, that stack is not automatically recovered when a snapshot is loaded. Applications are therefore responsible to restore the required command and event handling behavior from application-specific snapshot details in the <code class="docutils literal"><span class="pre">onSnapshot</span></code> handler. Of course, this is only necessary if the required behavior differs from the default <code class="docutils literal"><span class="pre">onEvent</span></code> and <code class="docutils literal"><span class="pre">onCommand</span></code> behavior.</p>
</div>
</div>
<div class="section" id="failure-handling">
<h1>Failure handling<a class="headerlink" href="#failure-handling" title="Permalink to this headline">¶</a></h1>
<p>Event-sourced components register themselves at an <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.EventLog">EventLog</a> actor in order to be notified about changes in the event log. Directly after registration, during recovery, they read from the event log in order to recover internal state from past events. After recovery has completed, the event log actor <strong>pushes</strong> newly written events to registered actors so that they can update application state with minimal latency. If a registered actor is restarted, it recovers again from the event log and continues to process push-updates after recovery has completed.</p>
<p>An <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.EventLog">EventLog</a> actor processes write requests from <a class="reference internal" href="#ref-event-sourced-actors"><span class="std std-ref">Event-sourced actors</span></a>, <a class="reference internal" href="#ref-event-sourced-processors"><span class="std std-ref">Event-sourced processors</span></a> and <a class="reference internal" href="event-log.html#replication-endpoints"><span class="std std-ref">Replication endpoints</span></a>. If a write succeeds it pushes the written events to registered actors (under consideration of <a class="reference internal" href="#event-routing"><span class="std std-ref">Event routing</span></a> rules) and handles the next write request. Writing to a storage backend may also fail for several reasons. In the following, it is assumed that writes are made to a remote storage backend such as the <a class="reference internal" href="event-log.html#cassandra-storage-backend"><span class="std std-ref">Cassandra storage backend</span></a>.</p>
<p>A write failure reported from a storage backend driver does not necessarily mean that the events have not been written to the storage backend. For example, a write could have been actually applied to the remote storage backend but the ACK message got lost. This usually causes the driver to report a timeout. If an event log actor would simply continue with the next write request, after having informed the event emitter about the failure, the emitter and and other registered actors would erroneously assume that the emitted events do not exist in the event log. However, these events may become visible to newly registered actors that are about to recover or to replication endpoints that read events for replication.</p>
<p>This would violate the event ordering and consistency guarantees made by Eventuate because some registered actors would see an event stream with missing events. The following describes two options to deal with that situation:</p>
<ol class="arabic simple">
<li>After a failed write, the event log actor notifies all registered actors to restart themselves so that another recovery phase would find out whether the events have been actually written or not. This is fine if the write failure was actually a lost ACK and the storage backend is immediately available for subsequent reads (neglecting a potentially high read load). If the write failure was because of a longer-lasting problem, such as a longer network partition that disconnects the application from the storage backend, registered actors would fail to recover and would be therefore be unavailable for in-memory reads.</li>
<li>The event log actor itself tries to find out whether the write was successful or not, either by reading from the storage backend or by retrying the write until it succeeds, before continuing with the next write request. In this case, the log actor would inform the event emitter either about a failed write if it can guarantee that the write has not been applied to the storage backend or about a successful write if retrying the write finally succeeded. Retrying writes can only be made to storage backends that support idempotent writes. With this strategy, registered actors don’t need be restarted and remain available for in-memory reads.</li>
</ol>
<p>In Eventuate, the second approach is taken. Should there be a longer-lasting problem with the storage backend, it may take a longer time for an event log actor to make a decision about the success or failure of a write. During that time, it will reject further writes in order to avoid being overloaded with pending write requests. This is an application of the <a class="reference external" href="http://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker</a> design pattern.</p>
<p>Consequently, a write failure reported by an event log actor means that the write was actually <strong>not</strong> applied to the storage backend. This additional guarantee comes at the cost of potentially long write reply delays but allows registered actors to remain available for in-memory reads during storage backend unavailability. It also provides clearer semantics of write failures.</p>
<div class="section" id="circuit-breaker">
<span id="id14"></span><h2>Circuit breaker<a class="headerlink" href="#circuit-breaker" title="Permalink to this headline">¶</a></h2>
<p>The strategy described above can be implemented by wrapping a <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.cassandra.CassandraEventLog">CassandraEventLog</a> in a <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.CircuitBreaker">CircuitBreaker</a> actor. This is the default when creating the log actor for a <a class="reference internal" href="event-log.html#cassandra-storage-backend"><span class="std std-ref">Cassandra storage backend</span></a>. Should the event log actor need to retry a write <code class="docutils literal"><span class="pre">eventuate.log.circuit-breaker.open-after-retries</span></code> times or more, the circuit breaker opens. If open, it rejects all requests by replying with a failure message that contains an <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.EventLogUnavailableException">EventLogUnavailableException</a>. If retrying the write finally succeeds, the circuit breaker closes again. The maximum number of write retries can be configured with <code class="docutils literal"><span class="pre">eventuate.log.cassandra.write-retry-max</span></code> and the delay between write retries with <code class="docutils literal"><span class="pre">eventuate.log.write-timeout</span></code>. If the maximum number of retries is reached, the event log actor gives up and stops itself which also stops all registered actors.</p>
</div>
<div class="section" id="persist-failure-handling">
<span id="id15"></span><h2><code class="docutils literal"><span class="pre">persist</span></code> failure handling<a class="headerlink" href="#persist-failure-handling" title="Permalink to this headline">¶</a></h2>
<p>Asynchronous <code class="docutils literal"><span class="pre">persist</span></code> operations send write requests to an <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.log.EventLog">EventLog</a> actor. The write reply is passed as argument to the persist handler (see section <a class="reference internal" href="#command-handler"><span class="std std-ref">Command handler</span></a>). If the persist handler is called with a <code class="docutils literal"><span class="pre">Failure</span></code> one can safely assume that the events have not been written to the storage backend. As already explained above, a consequence of this additional guarantee is that persist handler callbacks may be delayed indefinitely.</p>
<p>For an <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> with <code class="docutils literal"><span class="pre">stateSync</span></code> set to <code class="docutils literal"><span class="pre">true</span></code>, this means that further commands sent to that actor will be stashed until the current write completes. In this case, it is the responsibility of the application not to overload that actor with further commands. For example, an application could use timeouts for command replies and prevent sending further commands to that actor if a timeout occurred. After an application-defined delay, command sending can be resumed. This is comparable to using an application-level circuit breaker. Alternatively, an application could restart an event-sourced actor on command timeout and continue sending new commands to that actor after recovery succeeded. This however may take a while depending on the unavailability duration of the storage backend.</p>
<p><code class="docutils literal"><span class="pre">EventsourcedActor</span></code>s with <code class="docutils literal"><span class="pre">stateSync</span></code> set to <code class="docutils literal"><span class="pre">false</span></code> do not stash commands but rather send write requests immediately to the event log actor. If the log actor is busy retrying a write and the <a class="reference internal" href="#circuit-breaker"><span class="std std-ref">Circuit breaker</span></a> opens, later persist operations will be completed immediately with an <code class="docutils literal"><span class="pre">EventLogUnavailableException</span></code> failure, regardless whether the event-sourced actor has persist operations in progress or not. A persist operation of an <code class="docutils literal"><span class="pre">EventsourcedActor</span></code> with <code class="docutils literal"><span class="pre">stateSync</span></code> set to <code class="docutils literal"><span class="pre">true</span></code> will only be completed with an <code class="docutils literal"><span class="pre">EventLogUnavailableException</span></code> failure if that actor had no persist operation in progress at the time the circuit breaker opened.</p>
</div>
<div class="section" id="persistonevent-failure-handling">
<span id="persist-on-event-failure-handling"></span><h2><code class="docutils literal"><span class="pre">persistOnEvent</span></code> failure handling<a class="headerlink" href="#persistonevent-failure-handling" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">EventsourcedActor</span></code>s can also persist events in the <a class="reference internal" href="#event-handler"><span class="std std-ref">Event handler</span></a> if they additionally extend <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.PersistOnEvent">PersistOnEvent</a>. An asynchronous <code class="docutils literal"><span class="pre">persistOnEvent</span></code> operation may also fail for reasons explained in <a class="reference internal" href="#persist-failure-handling"><span class="std std-ref">persist failure handling</span></a>. If a <code class="docutils literal"><span class="pre">persistOnEvent</span></code> operation fails, the actor is automatically restarted by throwing a <code class="docutils literal"><span class="pre">PersistOnEventException</span></code>.</p>
</div>
<div class="section" id="recovery-failure-handling">
<h2>Recovery failure handling<a class="headerlink" href="#recovery-failure-handling" title="Permalink to this headline">¶</a></h2>
<p>As explained in section <a class="reference internal" href="#state-recovery"><span class="std std-ref">State recovery</span></a>, event-sourced components are stopped if their recovery fails. Applications should either define a custom <code class="docutils literal"><span class="pre">onRecovery</span></code> completion handler to obtain information about recovery failure details or just watch these actors if recovery failure details are not relevant.</p>
</div>
<div class="section" id="batch-write-failure-handling">
<h2>Batch write failure handling<a class="headerlink" href="#batch-write-failure-handling" title="Permalink to this headline">¶</a></h2>
<p>Events are written in batches. When using the <a class="reference internal" href="event-log.html#cassandra-storage-backend"><span class="std std-ref">Cassandra storage backend</span></a>, there’s a <em>warn threshold</em> and <em>fail threshold</em> for batch sizes. The default settings in <code class="docutils literal"><span class="pre">cassandra.yaml</span></code> are:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span># Caution should be taken on increasing the size of this threshold as it can
# lead to node instability.
batch_size_warn_threshold_in_kb: 5

# Fail any batch exceeding this value. 50kb (10x warn threshold) by default.
batch_size_fail_threshold_in_kb: 50
</pre></div>
</div>
<p>When the size of an event batch exceeds the <em>fail threshold</em>, the batch write fails with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">com</span><span class="o">.</span><span class="n">datastax</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="nc">InvalidQueryException</span><span class="k">:</span> <span class="kt">Batch</span> <span class="kt">too</span> <span class="kt">large</span>
</pre></div>
</div>
<p>The corresponding entry in the Cassandra system log is:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">ERROR</span> <span class="o">&lt;</span><span class="n">timestamp</span><span class="o">&gt;</span> <span class="nc">Batch</span> <span class="n">of</span> <span class="n">prepared</span> <span class="n">statements</span> <span class="k">for</span> <span class="o">[</span><span class="kt">eventuate.log_&lt;id&gt;</span><span class="o">]</span> <span class="n">is</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">103800</span><span class="o">,</span> <span class="n">exceeding</span> <span class="n">specified</span> <span class="n">threshold</span> <span class="n">of</span> <span class="mi">51200</span> <span class="n">by</span> <span class="mf">52600.</span> <span class="o">(</span><span class="n">see</span> <span class="n">batch_size_fail_threshold_in_kb</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If Eventuate is the only writer to the Cassandra cluster then it is safe to increase these thresholds to higher values as Eventuate only makes single-partition batch writes (see also <a class="reference external" href="https://issues.apache.org/jira/browse/CASSANDRA-8825">CASSANDRA-8825</a>).</p>
</div>
<p>If other applications additionally make multi-partition batch writes to the same Cassandra cluster then is recommended to reduce</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="o">-</span><span class="n">batch</span><span class="o">-</span><span class="n">size</span> <span class="k">=</span> <span class="mi">64</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">cassandra</span><span class="o">.</span><span class="n">index</span><span class="o">-</span><span class="n">update</span><span class="o">-</span><span class="n">limit</span> <span class="k">=</span> <span class="mi">64</span>
</pre></div>
</div>
<p>to a smaller value like <code class="docutils literal"><span class="pre">32</span></code>, for example, or even smaller. Failed replication writes or index writes are re-tried automatically by Eventuate. Failed <code class="docutils literal"><span class="pre">persist</span></code> operations must be re-tried by the application.</p>
</div>
<div class="section" id="batch-replication-failure-handling">
<h2>Batch replication failure handling<a class="headerlink" href="#batch-replication-failure-handling" title="Permalink to this headline">¶</a></h2>
<p>During replication, events are batch-transferred over the network. The maximum number of events per batch can be configured with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">eventuate</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="o">-</span><span class="n">batch</span><span class="o">-</span><span class="n">size</span> <span class="k">=</span> <span class="mi">64</span>
</pre></div>
</div>
<p>The maximum batch size in bytes the transport will accept is limited. If this limit is exceeded, batch transfer will fail. In this case, applications should either increase</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">remote</span><span class="o">.</span><span class="n">netty</span><span class="o">.</span><span class="n">tcp</span><span class="o">.</span><span class="n">maximum</span><span class="o">-</span><span class="n">frame</span><span class="o">-</span><span class="n">size</span> <span class="k">=</span> <span class="mi">128000</span><span class="n">b</span>
</pre></div>
</div>
<p>or decrease the event batch size.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Batch sizes in Eventuate are currently defined in units of events whereas <code class="docutils literal"><span class="pre">maximum-frame-size</span></code> is defined in bytes. This mismatch will be removed in a later release (see also <a class="reference external" href="https://github.com/RBMHTechnology/eventuate/issues/166">ticket 166</a>).</p>
</div>
</div>
</div>
<div class="section" id="custom-serialization">
<h1>Custom serialization<a class="headerlink" href="#custom-serialization" title="Permalink to this headline">¶</a></h1>
<div class="section" id="custom-event-serialization">
<span id="event-serialization"></span><h2>Custom event serialization<a class="headerlink" href="#custom-event-serialization" title="Permalink to this headline">¶</a></h2>
<p>Custom serializers for application-defined events can be configured with Akka&#8217;s <a class="reference external" href="http://doc.akka.io/docs/akka/2.4/scala/serialization.html">serialization extension</a>. For example, an application that wants to use a custom <code class="docutils literal"><span class="pre">MyDomainEventSerializer</span></code> for events of type <code class="docutils literal"><span class="pre">MyDomainEvent</span></code> (both defined in package <code class="docutils literal"><span class="pre">com.example</span></code>) should add the following configuration to <code class="docutils literal"><span class="pre">application.conf</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">actor</span> <span class="o">{</span>
  <span class="n">serializers</span> <span class="o">{</span>
    <span class="n">domain</span><span class="o">-</span><span class="n">event</span><span class="o">-</span><span class="n">serializer</span> <span class="k">=</span> <span class="s">&quot;com.example.MyDomainEventSerializer&quot;</span>
  <span class="o">}</span>

  <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
    <span class="s">&quot;com.example.MyDomainEvent&quot;</span> <span class="k">=</span> <span class="n">domain</span><span class="o">-</span><span class="n">event</span><span class="o">-</span><span class="n">serializer</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">MyDomainEventSerializer</span></code> must extend Akka’s <a class="reference external" href="http://doc.akka.io/api/akka/2.4/#akka.serialization.Serializer">Serializer</a> trait. Please refer to Akka’s <a class="reference external" href="http://doc.akka.io/docs/akka/2.4/scala/serialization.html">serialization extension</a> documentation for further details.</p>
<p>Eventuate stores application-defined events as <code class="docutils literal"><span class="pre">payload</span></code> of <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.DurableEvent">DurableEvent</a>s. <code class="docutils literal"><span class="pre">DurableEvent</span></code> itself is serialized with <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.serializer.DurableEventSerializer">DurableEventSerializer</a>, a <a class="reference external" href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a> based serializer that delegates <code class="docutils literal"><span class="pre">payload</span></code> serialization to a custom serializer. If no custom serializer is configured, Akka’s default serializer is used.</p>
</div>
<div class="section" id="custom-replication-filter-serialization">
<span id="replication-filter-serialization"></span><h2>Custom replication filter serialization<a class="headerlink" href="#custom-replication-filter-serialization" title="Permalink to this headline">¶</a></h2>
<p>In the same way as for application-defined events, custom serializers for <a class="reference internal" href="event-log.html#replication-filters"><span class="std std-ref">Replication filters</span></a> can also be configured via Akka&#8217;s <a class="reference external" href="http://doc.akka.io/docs/akka/2.4/scala/serialization.html">serialization extension</a>. For example, an application that wants to use a custom <code class="docutils literal"><span class="pre">MyReplicationFilterSerializer</span></code> for replication filters of type <code class="docutils literal"><span class="pre">MyReplicationFilter</span></code> (both defined in package <code class="docutils literal"><span class="pre">com.example</span></code>) should add the following configuration to <code class="docutils literal"><span class="pre">application.conf</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">actor</span> <span class="o">{</span>
  <span class="n">serializers</span> <span class="o">{</span>
    <span class="n">custom</span><span class="o">-</span><span class="n">filter</span><span class="o">-</span><span class="n">serializer</span> <span class="k">=</span> <span class="s">&quot;com.example.MyReplicationFilterSerializer&quot;</span>
  <span class="o">}</span>

  <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
    <span class="s">&quot;com.example.MyReplicationFilter&quot;</span> <span class="k">=</span> <span class="n">custom</span><span class="o">-</span><span class="n">filter</span><span class="o">-</span><span class="n">serializer</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Custom replication filter serialization also works if the custom filter is part of a composite filter that has been composed with <code class="docutils literal"><span class="pre">and</span></code> or <code class="docutils literal"><span class="pre">or</span></code> combinators (see <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.ReplicationFilter">ReplicationFilter</a> API). If no custom filter serializer is configured, Akka’s default serializer is used.</p>
</div>
<div class="section" id="custom-snapshot-serialization">
<span id="snapshot-serialization"></span><h2>Custom snapshot serialization<a class="headerlink" href="#custom-snapshot-serialization" title="Permalink to this headline">¶</a></h2>
<p>Applications can also configure custom serializers for snapshots in the same way as for application-defined events and replication filters (see sections <a class="reference internal" href="#event-serialization"><span class="std std-ref">Custom event serialization</span></a> and <a class="reference internal" href="#replication-filter-serialization"><span class="std std-ref">Custom replication filter serialization</span></a>).</p>
<p>Custom snapshot serialization also works for state managed with <code class="docutils literal"><span class="pre">ConcurrentVersions[A,</span> <span class="pre">B]</span></code>. A custom serializer configured for type parameter <code class="docutils literal"><span class="pre">A</span></code> is used whenever a snapshot of type <code class="docutils literal"><span class="pre">ConcurrentVersions[A,</span> <span class="pre">B]</span></code> is saved (see also <a class="reference internal" href="../user-guide.html#tracking-conflicting-versions"><span class="std std-ref">Tracking conflicting versions</span></a>).</p>
<p>Event-sourced actors that extend <code class="docutils literal"><span class="pre">ConfirmedDelivery</span></code> for <a class="reference internal" href="#reliable-delivery"><span class="std std-ref">Reliable delivery</span></a> of messages to destinations will also include unconfirmed messages as <code class="docutils literal"><span class="pre">deliveryAttempts</span></code> in a <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.Snapshot">Snapshot</a>. The <code class="docutils literal"><span class="pre">message</span></code> field of a <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.ConfirmedDelivery$$DeliveryAttempt">DeliveryAttempt</a> can also be custom-serialized by configuring a serializer.</p>
</div>
<div class="section" id="custom-crdt-serialization">
<h2>Custom CRDT serialization<a class="headerlink" href="#custom-crdt-serialization" title="Permalink to this headline">¶</a></h2>
<p>Custom serializers can also be configured for the type parameter <code class="docutils literal"><span class="pre">A</span></code> of <code class="docutils literal"><span class="pre">MVRegister[A]</span></code>, <code class="docutils literal"><span class="pre">LWWRegister[A]</span></code> and <code class="docutils literal"><span class="pre">ORSet[A]</span></code> <a class="reference internal" href="../user-guide.html#commutative-replicated-data-types"><span class="std std-ref">Operation-based CRDTs</span></a>. These serializers are used for both persistent CRDT operations and CRDT snapshots.</p>
</div>
<div class="section" id="resolution-of-serializers-when-deserializing">
<h2>Resolution of serializers when deserializing<a class="headerlink" href="#resolution-of-serializers-when-deserializing" title="Permalink to this headline">¶</a></h2>
<p>When eventuate serializes application-defined events, <a class="reference internal" href="event-log.html#replication-filters"><span class="std std-ref">Replication filters</span></a> or snapshots it includes the <code class="docutils literal"><span class="pre">identifier</span></code> of the Akka serializer and the class or string based <a class="reference external" href="http://doc.akka.io/docs/akka/2.4/scala/serialization.html#Serializer_with_String_Manifest">manifest</a> when available. When deserializing these application-defined payloads a serializer is selected as follows:</p>
<ul class="simple">
<li>If a class-based manifest is included, the serializer that is configured in the Akka configuration for this class is selected</li>
<li>In case of a string-based manifest or no manifest the serializer is selected by the included <code class="docutils literal"><span class="pre">identifier</span></code></li>
</ul>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>The <code class="docutils literal"><span class="pre">customDestinationAggregateIds</span></code> parameter is described in section <a class="reference internal" href="#event-routing"><span class="std std-ref">Event routing</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Writes from different event-sourced actors that have <code class="docutils literal"><span class="pre">stateSync</span></code> set to <code class="docutils literal"><span class="pre">true</span></code> are still batched, but not the writes from a single event-sourced actor.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>Event replay can optionally start from <a class="reference internal" href="#snapshots"><span class="std std-ref">Recovery using an application-defined log sequence number</span></a> of actor state.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td>Event-sourced processors can additionally route events between event logs.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[5]</a></td><td>The routing destinations of a <a class="reference external" href="../latest/api/index.html#com.rbmhtechnology.eventuate.DurableEvent">DurableEvent</a> can be obtained with its <code class="docutils literal"><span class="pre">destinationAggregateIds</span></code> method.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
		    
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="adapters.html" class="float-right" title="Adapters">Next</a>
      
      
        <a href="event-log.html" title="Event log">Previous</a>
      
    </div>
  
        </div>
	  </div>
    <div class="wrapper-footer">
<footer>
  <div role="contentinfo">
    <p>
        &copy; Copyright 2015 - 2016 Red Bull Media House.  | <a href="http://rbmhtechnology.github.io/imprint" target="_blank">Imprint</a> | <a href="http://rbmhtechnology.github.io/termsconditions" target="_blank">Terms &amp; Conditions</a> | <a href="http://rbmhtechnology.github.io/dataprivacypolicy" target="_blank">Data Privacy Policy</a> 
    </p>
  </div>

</footer>
</div>
      
    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.8-SNAPSHOT',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/tabbedcode.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>